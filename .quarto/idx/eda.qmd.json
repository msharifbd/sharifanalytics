{"title":"Exploratory Data Analysis (EDA)","markdown":{"yaml":{"title":"Exploratory Data Analysis (EDA)","format":"html"},"headingText":"Learning Objectives of the Chapter","headingAttr":{"id":"","classes":["unnumbered"],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n\n::: {style=\"text-align: justify\"}\nAt the End of the Chapter, Students should be Able to -\n\n-   Learn about the purpose of Exploratory Data Analysis (EDA)\n\n-   Understand different techniques of transforming and cleaning data\n\n-   Learn about Different R and Python Packages for EDA\n\n-   Understand how to use six verbs for EDA\n\n-   Perform EDA on some real world data sets. \n\n-   Learn about how to interpret results from EDA\n:::\n\n\n## Introduction \n\n::: {style=\"text-align: justify\"}\n     In descriptive statistics, we summarize the data using different metrics such as mean, median, standard deviation, minimum value, maximum value, and percentile. Descriptive statisics is also called summary statistics.\n:::\n\n## Data Collection & Importing \n\n\n## Data Cleaning \n\n\n## Packages for Exploratory Data Analysis (EDA)\n\n::: {style=\"text-align: justify\"}\n     In order to use `pyjanitor`, the data frame must be pandas because `pyjanitor` extends pandas data frame functionality. \n:::\n\n\n::: {.panel-tabset}\n\n## dplyr\n\n```{r}\n#| warning: false\n# loading packages\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(janitor)\n```\n\n```{r}\n#| include: false\nlibrary(reticulate)\nSys.unsetenv(\"RETICULATE_PYTHON\")\nreticulate::use_virtualenv(\"C:/Users/mshar/OneDrive - Southern Illinois University/ANALYTICS_FOR_ACCOUNTING_DATA/accounting_analytics_book\", required = TRUE)\n#Sys.setenv('RETICULATE_PYTHON' = 'C:\\\\Users\\\\mshar\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\python.exe')\n#py_install(\"pyjanitor\")\n#py_install(\"polars\")\n#Sys.setenv('RETICULATE_PYTHON' = '~/.venv/quarto_book_python/Scripts/python.exe')\n```\n\n\n## pandas \n```{python}\n# loading the package\nimport numpy as np\nimport pandas as pd\n# from pyjanitor package \n# pip install pyjanitor\nimport janitor \nfrom janitor import clean_names, remove_empty\n```\n\n:::\n\n## Importing the Dataset \n\n::: {.panel-tabset}\n\n## dplyr\n```{r}\n#| warning: false\n# importing data frame \ndf = read_csv(\"https://raw.githubusercontent.com/msharifbd/DATA/main/Al-Bundy_raw-data.csv\")\n```\n\n## pandas \n```{python}\n# importing data frame \ndf_pd = pd.read_csv(\"https://raw.githubusercontent.com/msharifbd/DATA/main/Al-Bundy_raw-data.csv\")\n```\n\n\n\n:::\n\n## Meta Data\n\n::: {style=\"text-align: justify\"}\n     Meta data is data about the data. Before we put the data into analysis, we need to learn about our dataset. This learning invovles knowing about the number of rows, number of columns, the types of the fields, the appropriateness of those types, the missing values in the dataset and so on. \n:::\n\n::: {.panel-tabset}\n\n## dplyr \n\n```{r}\nglimpse(df)\n```\n\n\n```{r}\nmap_df(df, ~sum(is.na(.))) |>\n     glimpse()\n```\n\n```{r}\nncol(df)\nnrow(df)\n```\n\n```{r}\nhead(df)\n```\n\n```{r}\ntail(df)\n```\n\n```{r}\ndplyr::sample_n(df, 10)\n```\n\n\n## Pandas \n\n```{python}\ndf_pd.info()\n```\n\n```{python}\ndf_pd.shape\n```\n\n```{python}\nprint('The total number of rows and columns of the product data is \\\n {} and {} respectively.'.format(df_pd.shape[0], df_pd.shape[1]))\n```\n\n\n```{python}\nprint(f'The total number of rows and columns of the product data is \\\n {df_pd.shape[0]} and {df_pd.shape[1]} respectively.')\n```\n\n```{python}\ndf_pd.columns\n```\n\n```{python}\ndf_pd.head()\n```\n\n```{python}\ndf_pd.tail()\n```\n\n```{python}\ndf_pd.isna().sum()\n```\n\n\n```{python}\ndf_pd.dtypes\n```\n\n```{python}\ndf_pd.sample(n=10)\n```\n\n\n:::\n\n## Cleaning the Dataset \n\n::: {.panel-tabset}\n\n## dplyr\n\n```{r}\n df |>\n     rename_all(toupper) |>\n     janitor::clean_names() |>\n     rename_all(toupper) |>\n     glimpse()\n```\n\n```{r}\n df = df |>\n     rename_all(toupper) |>\n     janitor::clean_names() |>\n     rename_all(toupper)\nglimpse(df)\n```\n\n\n## panads \n\n```{python}\ndf_pd.columns.str.upper().to_list()\n```\n\n```{python}\n(df_pd\n     .pipe(remove_empty)\n     .pipe(lambda x: x.clean_names(case_type = \"upper\"))\n     .pipe(lambda x: x.rename(columns = {'SIZE_US_': 'SIZE_US', 'SIZE_EUROPE_':\"SIZE_EUROPE\", \"SIZE_UK_\":\"SIZE_UK\"}))\n     .pipe(lambda x: x.info())\n     )\n```\n\n```{python}\n# Changing the names of the columns to uppercase\ndf_pd.rename(columns = str.upper, inplace = True)\ndf_pd.columns\n```\n\n\n```{python}\n#| warning: false\nnew_column = df_pd.columns \\\n .str.replace(\"(\", '').str.replace(\")\", \"\") \\\n .str.replace(' ','_') # Cleaning the names of the variables\nnew_column\n```\n\n\n```{python}\ndf_pd.columns = new_column\ndf_pd.columns\ndf_pd.rename(columns=str.upper, inplace = True)\ndf_pd.columns \n\n```\n\n\n::: \n\n\n### Changing the Types of Variables \n\n::: {.panel-tabset}\n\n## dplyr\n\n```{r}\ndf |>\n    mutate (DATE = lubridate::mdy(DATE)) |>\n    glimpse()\n```\n\n     From the above, it is now evident the the type of the `DATE` variable now is `date`. \n\n```{r}\ndf |>\n    mutate (DATE = lubridate::mdy(DATE)) |>\n    mutate (PRODUCTID = as.character(PRODUCTID)) |>\n    glimpse()\n```\n\n     From the above, it is now evident the the type of the `DATE` and `PRODUCTID` variable now is date (`date`) and character (`chr`) respectively. We can now incorparte the changes into the data frame. \n\n```{r}\ndf = df |>\n    mutate (DATE = lubridate::mdy(DATE)) |>\n    mutate (PRODUCTID = as.character(PRODUCTID)) \nglimpse(df)\n```\n\n\n## pandas \n\n```{python}\n(\n    df_pd\n    .pipe(lambda x: x.assign(DATE = pd.to_datetime(x['DATE'])))\n    .pipe(lambda x: x.info())\n)\n\n```\n\n\n```{python}\n# converting integer to object\ndf_pd.INVOICENO = df_pd.INVOICENO.astype(str)\ndf_pd[['MONTH', 'PRODUCTID']] = df_pd[['MONTH', 'PRODUCTID']].astype(str)\ndf_pd.info()\n```\n\n\n\n:::\n\n## Some Other Useful Functions \n     There are some other useful functions that can be used to explore the dataset for analysis. Some of those useful functions are discussed below. \n\n:::{.panel-tabset}\n\n\n## dplyr\n\n```{r}\ndf|> count(YEAR)\n```\n\n```{r}\ndf|> count(COUNTRY)\n```\n\n```{r}\ndf|> distinct(COUNTRY)\n```\n\n## pandas \n```{python}\ndf_pd['YEAR'].value_counts()\n```\n\n```{python}\ndf_pd['YEAR'].unique()\n```\n\n\n:::\n\n\n## Six Verbs for EDA \n\n     @tbl-compareDplyrPandas shows the comparable functions in both `dplyr` and `pandas` packages. These functions are very much important to perform exploratory data analysis in both `R` and `Python`. `group_by` (`groupby` in pandas) and `summarize ()`^[You can also use British spelling - `summarise ()`] (`agg ()` in pandas) are often used together; therefore, they are in the same group in @tbl-compareDplyrPandas. \n\n```{r}\n#| include: false\ntidyverse_pandas = tibble::tribble(\n  ~`Verb Number`,~`tidyverse`, ~ `pandas`, \n  '1','filter ()', 'query () or loc () or iloc ()',\n  '2','arrange ()', 'sort_values ()',\n  '3','select ()', 'filter () or loc ()',\n  '4','rename ()', 'rename ()',\n  '5','mutate ()', 'assign ()',\n  '6','group_by ()', 'groupby ()',\n  '6','summarize ()', 'agg ()'\n)\n\n```\n\n```{r}\n#| label: tbl-compareDplyrPandas\n#| tbl-cap: Tidyverse and Pandas Equivalent Functions \n#| echo: false\n#| warning: false\n# These are R code to prepare Table 2 using KableExtra \nlibrary(kableExtra)\nkbl(tidyverse_pandas, booktabs = TRUE \n    #,caption = \"Tidyverse and Pandas Equivalent Functions\"\n    ) %>% \n  kable_styling(latex_options = c ('striped', 'hold_positions'))\n```\n\n### 1st Verb - filter () Function \n\n     Filter functions are used to subset a data frame based on rows, meaning that retaining rows that satisfy given conditions. Filtering rows is also called slicing^[Indexing involves obtaining individual elements.] becasue we obtain a set of elements by filtering.  \n\n:::{.panel-tabset}\n\n## dplyr \n\n```{r}\ndf |> filter (YEAR == \"2015\")\n```\n\n```{r}\ndf |> filter (COUNTRY %in% c(\"United States\", \"Canada\"))\n```\n\n```{r}\ndf |> filter (COUNTRY == \"United States\", YEAR == \"2016\")\n```\n\n```{r}\ndf |> filter (COUNTRY == \"United States\", YEAR %in% c(\"2015\",\"2016\"))\n```\n\n```{r}\ndf |> filter (COUNTRY %in% c(\"United States\", \"Canada\"), YEAR == \"2014\")\n```\n\n\n## pandas \n\n```{python}\ndf_pd.query(\"YEAR == 2015\")\n```\n\n```{python}\ndf_pd.query('COUNTRY== \"United States\" | COUNTRY == \"Canada\"')\n```\n\n```{python}\ndf_pd.query(\"COUNTRY in ['United States', 'Canada']\")\n```\n\n```{python}\ndf_pd.query(\"COUNTRY== 'United States' & YEAR== 2016\")\n```\n\n```{python}\ndf_pd.query(\"COUNTRY== 'United States' & YEAR in [2015,2016]\")\n```\n\n```{python}\ndf_pd[df_pd['COUNTRY'] == \"United States\"]\n```\n\n```{python}\ndf_pd.loc[(df_pd['COUNTRY']==\"United States\")]\n```\n\n\n```{python}\ndf_pd.loc[df_pd['COUNTRY'].isin([\"United States\", \"Canada\"])]\n```\n\n```{python}\ndf_pd.loc[df_pd['COUNTRY']\\\n .isin([\"United States\", \"Canada\"]) &(df_pd['YEAR']==2014)]\n```\n\n```{python}\ndf_pd.loc[(df_pd['COUNTRY']==\"United States\") &(df_pd [\"YEAR\"] ==2014)]\n```\n\n```{python}\ndf_pd.loc[df_pd['COUNTRY'] == \"United States\", :]\n```\n\n```{python}\ndf_pd.loc[\n    df_pd['COUNTRY']=='United States',\n    ['COUNTRY', \"UNITPRICE\", \"SALEPRICE\"]]\n```\n\n:::\n\n### 2nd Verb - arrange () Function \n\n     In arrange functions, we order the rows of a data frame by the values of given columns. It is like sorting or odering the data. \n\n:::{.panel-tabset}\n\n## dplyr \n```{r}\ndf |>\n    arrange(DATE)     \n```\n\n```{r}\ndf |>\n    arrange(desc(DATE))     \n```\n\n\n```{r}\ndf |>\n    arrange(MONTH, SALEPRICE)     \n```\n\n\n\n## pandas \n```{python}\ndf_pd.sort_values(by =['DATE'])   \n```\n\n```{python}\ndf_pd.sort_values(by =['DATE'], ascending = False)   \n```\n\n```{python}\ndf_pd.sort_values(by =['MONTH', 'SALEPRICE'])\n```\n\n\n:::\n\n\n### 3rd Verb - select () Function \n     Select functions help to select or obtain columns from the data frame. When there are a lot of columns in our dataset, select functions become very useful. \n\n:::{.panel-tabset}\n\n## dplyr \n```{r}\ndf |> select(DATE, UNITPRICE, DISCOUNT)   \n```\n\n\n```{r}\ndf |> select(1:2, 5:8)  \n```\n\n```{r}\ndf |>\n    select(starts_with('SIZE'))\n```\n\n```{r}\ndf |>\n    select(ends_with('PRICE'))\n```\n\n\n```{r}\ndf |>\n    select(contains(\"_\"))\n```\n\n```{r}\ndf |>\n    select(matches(\"SIZE\"))\n```\n\n```{r}\ndf |>\n    select(matches(\"PRICE$\"))\n```\n\n```{r}\n# starts with letter S\ndf |>\n    select(matches(\"^S\"))\n```\n\n\n```{r}\ndf |>\n    select(where(is.character))\n```\n\n```{r}\ndf |>\n    select(where(is.numeric))\n```\n\n```{r}\ndf |>\n    select(MONTH, YEAR, everything())\n```\n\n```{r}\n# any_of () vs all_of ()\ndf |>\n    select(any_of(c(\"PRICE\", \"SIZE\")))\n```\n\n\n```{r}\n# Dropping columns \ndf |>\n    select(-DATE)\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## pandas \n```{python}\ndf_pd['DATE']   \n```\n\n```{python}\ndf_pd[['DATE', 'UNITPRICE']]   \n```\n\n```{python}\ndf_pd.loc[:,['DATE', 'UNITPRICE']]   \n```\n\n\n```{python}\ndf_pd.iloc[:,5:8]\n```\n\n```{python}\ndf_pd.iloc[:,[3,5,8]]\n```\n\n```{python}\ndf_pd.filter(['YEAR','SALEPRICE', 'DISCOUNT', 'UNITPRICE'])\n```\n\n```{python}\ndf_pd.filter(['YEAR','SALEPRICE', 'DISCOUNT', 'UNITPRICE'])\n```\n\n```{python}\n #RegularExpression(Regex)\ndf_pd.filter(regex =\"PRICE$\") #Ends with Price\n```\n\n```{python}\ndf_pd.filter(regex =\"ˆSIZE\") #Starts with SIZE\n```\n\n\n```{python}\ndf_pd.filter(regex =\"PRICE\") #Contains the word Price\n```\n\n```{python}\ndf_pd.select_dtypes('object')\n```\n\n```{python}\ndf_pd.select_dtypes('int')\n```\n\n```{python}\ndf_pd.loc[:,df_pd.columns.str.startswith('SIZE')]\n```\n\n```{python}\ndf_pd.loc[:,df_pd.columns.str.contains('PRICE')]\n```\n\n```{python}\ndf_pd.loc[:,df_pd.columns.str.endswith('PRICE')]\n```\n\n\n```{python}\n# Dropping columns \ndf_pd.drop(columns =['SIZE_EUROPE', 'SIZE_UK'], axis=1)\n```\n\n```{python}\n# Dropping columns \ndf_pd.drop(columns =['SIZE_EUROPE', 'SIZE_UK'], axis=1)\\\n    .pipe(lambda x: x.info())\n```\n\n```{python}\n# Rearranging columns \n# Sorting Alphabetically\ndf_pd.reindex(sorted(df_pd.columns), axis =1)\n```\n\n```{python}\n# Rearranging columns \n# Sorting As You Want (ASY)\n\ncol_first = ['YEAR','MONTH']\ncol_rest = df_pd.columns.difference(col_first, sort=False).to_list()\ndf_pd2 = df_pd [col_first +col_rest]\ndf_pd2.info()\n```\n\n```{python}\n\n```\n\n```{python}\n\n```\n\n```{python}\n\n```\n\n```{python}\n\n```\n\n```{python}\n\n```\n\n:::\n\n\n### 4th Verb - rename () Function \n\n:::{.panel-tabset}\n\n## dplyr \n```{r}\n\n     \n```\n\n## pandas \n```{python}\ndf_pd \n```\n\n:::\n\n### 5th Verb - mutate () Function \n\n:::{.panel-tabset}\n\n## dplyr \n```{r}\n\n     \n```\n\n## pandas \n```{python}\n\n     \n```\n\n:::\n\n### 6th Verbs - group_by () and summarize () Functions \n\n:::{.panel-tabset}\n\n## dplyr \n```{r}\n\n     \n```\n\n## pandas \n```{python}\n\n     \n```\n\n:::\n","srcMarkdownNoYaml":"\n\n### Learning Objectives of the Chapter {.unnumbered}\n\n::: {style=\"text-align: justify\"}\nAt the End of the Chapter, Students should be Able to -\n\n-   Learn about the purpose of Exploratory Data Analysis (EDA)\n\n-   Understand different techniques of transforming and cleaning data\n\n-   Learn about Different R and Python Packages for EDA\n\n-   Understand how to use six verbs for EDA\n\n-   Perform EDA on some real world data sets. \n\n-   Learn about how to interpret results from EDA\n:::\n\n\n## Introduction \n\n::: {style=\"text-align: justify\"}\n     In descriptive statistics, we summarize the data using different metrics such as mean, median, standard deviation, minimum value, maximum value, and percentile. Descriptive statisics is also called summary statistics.\n:::\n\n## Data Collection & Importing \n\n\n## Data Cleaning \n\n\n## Packages for Exploratory Data Analysis (EDA)\n\n::: {style=\"text-align: justify\"}\n     In order to use `pyjanitor`, the data frame must be pandas because `pyjanitor` extends pandas data frame functionality. \n:::\n\n\n::: {.panel-tabset}\n\n## dplyr\n\n```{r}\n#| warning: false\n# loading packages\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(janitor)\n```\n\n```{r}\n#| include: false\nlibrary(reticulate)\nSys.unsetenv(\"RETICULATE_PYTHON\")\nreticulate::use_virtualenv(\"C:/Users/mshar/OneDrive - Southern Illinois University/ANALYTICS_FOR_ACCOUNTING_DATA/accounting_analytics_book\", required = TRUE)\n#Sys.setenv('RETICULATE_PYTHON' = 'C:\\\\Users\\\\mshar\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\python.exe')\n#py_install(\"pyjanitor\")\n#py_install(\"polars\")\n#Sys.setenv('RETICULATE_PYTHON' = '~/.venv/quarto_book_python/Scripts/python.exe')\n```\n\n\n## pandas \n```{python}\n# loading the package\nimport numpy as np\nimport pandas as pd\n# from pyjanitor package \n# pip install pyjanitor\nimport janitor \nfrom janitor import clean_names, remove_empty\n```\n\n:::\n\n## Importing the Dataset \n\n::: {.panel-tabset}\n\n## dplyr\n```{r}\n#| warning: false\n# importing data frame \ndf = read_csv(\"https://raw.githubusercontent.com/msharifbd/DATA/main/Al-Bundy_raw-data.csv\")\n```\n\n## pandas \n```{python}\n# importing data frame \ndf_pd = pd.read_csv(\"https://raw.githubusercontent.com/msharifbd/DATA/main/Al-Bundy_raw-data.csv\")\n```\n\n\n\n:::\n\n## Meta Data\n\n::: {style=\"text-align: justify\"}\n     Meta data is data about the data. Before we put the data into analysis, we need to learn about our dataset. This learning invovles knowing about the number of rows, number of columns, the types of the fields, the appropriateness of those types, the missing values in the dataset and so on. \n:::\n\n::: {.panel-tabset}\n\n## dplyr \n\n```{r}\nglimpse(df)\n```\n\n\n```{r}\nmap_df(df, ~sum(is.na(.))) |>\n     glimpse()\n```\n\n```{r}\nncol(df)\nnrow(df)\n```\n\n```{r}\nhead(df)\n```\n\n```{r}\ntail(df)\n```\n\n```{r}\ndplyr::sample_n(df, 10)\n```\n\n\n## Pandas \n\n```{python}\ndf_pd.info()\n```\n\n```{python}\ndf_pd.shape\n```\n\n```{python}\nprint('The total number of rows and columns of the product data is \\\n {} and {} respectively.'.format(df_pd.shape[0], df_pd.shape[1]))\n```\n\n\n```{python}\nprint(f'The total number of rows and columns of the product data is \\\n {df_pd.shape[0]} and {df_pd.shape[1]} respectively.')\n```\n\n```{python}\ndf_pd.columns\n```\n\n```{python}\ndf_pd.head()\n```\n\n```{python}\ndf_pd.tail()\n```\n\n```{python}\ndf_pd.isna().sum()\n```\n\n\n```{python}\ndf_pd.dtypes\n```\n\n```{python}\ndf_pd.sample(n=10)\n```\n\n\n:::\n\n## Cleaning the Dataset \n\n::: {.panel-tabset}\n\n## dplyr\n\n```{r}\n df |>\n     rename_all(toupper) |>\n     janitor::clean_names() |>\n     rename_all(toupper) |>\n     glimpse()\n```\n\n```{r}\n df = df |>\n     rename_all(toupper) |>\n     janitor::clean_names() |>\n     rename_all(toupper)\nglimpse(df)\n```\n\n\n## panads \n\n```{python}\ndf_pd.columns.str.upper().to_list()\n```\n\n```{python}\n(df_pd\n     .pipe(remove_empty)\n     .pipe(lambda x: x.clean_names(case_type = \"upper\"))\n     .pipe(lambda x: x.rename(columns = {'SIZE_US_': 'SIZE_US', 'SIZE_EUROPE_':\"SIZE_EUROPE\", \"SIZE_UK_\":\"SIZE_UK\"}))\n     .pipe(lambda x: x.info())\n     )\n```\n\n```{python}\n# Changing the names of the columns to uppercase\ndf_pd.rename(columns = str.upper, inplace = True)\ndf_pd.columns\n```\n\n\n```{python}\n#| warning: false\nnew_column = df_pd.columns \\\n .str.replace(\"(\", '').str.replace(\")\", \"\") \\\n .str.replace(' ','_') # Cleaning the names of the variables\nnew_column\n```\n\n\n```{python}\ndf_pd.columns = new_column\ndf_pd.columns\ndf_pd.rename(columns=str.upper, inplace = True)\ndf_pd.columns \n\n```\n\n\n::: \n\n\n### Changing the Types of Variables \n\n::: {.panel-tabset}\n\n## dplyr\n\n```{r}\ndf |>\n    mutate (DATE = lubridate::mdy(DATE)) |>\n    glimpse()\n```\n\n     From the above, it is now evident the the type of the `DATE` variable now is `date`. \n\n```{r}\ndf |>\n    mutate (DATE = lubridate::mdy(DATE)) |>\n    mutate (PRODUCTID = as.character(PRODUCTID)) |>\n    glimpse()\n```\n\n     From the above, it is now evident the the type of the `DATE` and `PRODUCTID` variable now is date (`date`) and character (`chr`) respectively. We can now incorparte the changes into the data frame. \n\n```{r}\ndf = df |>\n    mutate (DATE = lubridate::mdy(DATE)) |>\n    mutate (PRODUCTID = as.character(PRODUCTID)) \nglimpse(df)\n```\n\n\n## pandas \n\n```{python}\n(\n    df_pd\n    .pipe(lambda x: x.assign(DATE = pd.to_datetime(x['DATE'])))\n    .pipe(lambda x: x.info())\n)\n\n```\n\n\n```{python}\n# converting integer to object\ndf_pd.INVOICENO = df_pd.INVOICENO.astype(str)\ndf_pd[['MONTH', 'PRODUCTID']] = df_pd[['MONTH', 'PRODUCTID']].astype(str)\ndf_pd.info()\n```\n\n\n\n:::\n\n## Some Other Useful Functions \n     There are some other useful functions that can be used to explore the dataset for analysis. Some of those useful functions are discussed below. \n\n:::{.panel-tabset}\n\n\n## dplyr\n\n```{r}\ndf|> count(YEAR)\n```\n\n```{r}\ndf|> count(COUNTRY)\n```\n\n```{r}\ndf|> distinct(COUNTRY)\n```\n\n## pandas \n```{python}\ndf_pd['YEAR'].value_counts()\n```\n\n```{python}\ndf_pd['YEAR'].unique()\n```\n\n\n:::\n\n\n## Six Verbs for EDA \n\n     @tbl-compareDplyrPandas shows the comparable functions in both `dplyr` and `pandas` packages. These functions are very much important to perform exploratory data analysis in both `R` and `Python`. `group_by` (`groupby` in pandas) and `summarize ()`^[You can also use British spelling - `summarise ()`] (`agg ()` in pandas) are often used together; therefore, they are in the same group in @tbl-compareDplyrPandas. \n\n```{r}\n#| include: false\ntidyverse_pandas = tibble::tribble(\n  ~`Verb Number`,~`tidyverse`, ~ `pandas`, \n  '1','filter ()', 'query () or loc () or iloc ()',\n  '2','arrange ()', 'sort_values ()',\n  '3','select ()', 'filter () or loc ()',\n  '4','rename ()', 'rename ()',\n  '5','mutate ()', 'assign ()',\n  '6','group_by ()', 'groupby ()',\n  '6','summarize ()', 'agg ()'\n)\n\n```\n\n```{r}\n#| label: tbl-compareDplyrPandas\n#| tbl-cap: Tidyverse and Pandas Equivalent Functions \n#| echo: false\n#| warning: false\n# These are R code to prepare Table 2 using KableExtra \nlibrary(kableExtra)\nkbl(tidyverse_pandas, booktabs = TRUE \n    #,caption = \"Tidyverse and Pandas Equivalent Functions\"\n    ) %>% \n  kable_styling(latex_options = c ('striped', 'hold_positions'))\n```\n\n### 1st Verb - filter () Function \n\n     Filter functions are used to subset a data frame based on rows, meaning that retaining rows that satisfy given conditions. Filtering rows is also called slicing^[Indexing involves obtaining individual elements.] becasue we obtain a set of elements by filtering.  \n\n:::{.panel-tabset}\n\n## dplyr \n\n```{r}\ndf |> filter (YEAR == \"2015\")\n```\n\n```{r}\ndf |> filter (COUNTRY %in% c(\"United States\", \"Canada\"))\n```\n\n```{r}\ndf |> filter (COUNTRY == \"United States\", YEAR == \"2016\")\n```\n\n```{r}\ndf |> filter (COUNTRY == \"United States\", YEAR %in% c(\"2015\",\"2016\"))\n```\n\n```{r}\ndf |> filter (COUNTRY %in% c(\"United States\", \"Canada\"), YEAR == \"2014\")\n```\n\n\n## pandas \n\n```{python}\ndf_pd.query(\"YEAR == 2015\")\n```\n\n```{python}\ndf_pd.query('COUNTRY== \"United States\" | COUNTRY == \"Canada\"')\n```\n\n```{python}\ndf_pd.query(\"COUNTRY in ['United States', 'Canada']\")\n```\n\n```{python}\ndf_pd.query(\"COUNTRY== 'United States' & YEAR== 2016\")\n```\n\n```{python}\ndf_pd.query(\"COUNTRY== 'United States' & YEAR in [2015,2016]\")\n```\n\n```{python}\ndf_pd[df_pd['COUNTRY'] == \"United States\"]\n```\n\n```{python}\ndf_pd.loc[(df_pd['COUNTRY']==\"United States\")]\n```\n\n\n```{python}\ndf_pd.loc[df_pd['COUNTRY'].isin([\"United States\", \"Canada\"])]\n```\n\n```{python}\ndf_pd.loc[df_pd['COUNTRY']\\\n .isin([\"United States\", \"Canada\"]) &(df_pd['YEAR']==2014)]\n```\n\n```{python}\ndf_pd.loc[(df_pd['COUNTRY']==\"United States\") &(df_pd [\"YEAR\"] ==2014)]\n```\n\n```{python}\ndf_pd.loc[df_pd['COUNTRY'] == \"United States\", :]\n```\n\n```{python}\ndf_pd.loc[\n    df_pd['COUNTRY']=='United States',\n    ['COUNTRY', \"UNITPRICE\", \"SALEPRICE\"]]\n```\n\n:::\n\n### 2nd Verb - arrange () Function \n\n     In arrange functions, we order the rows of a data frame by the values of given columns. It is like sorting or odering the data. \n\n:::{.panel-tabset}\n\n## dplyr \n```{r}\ndf |>\n    arrange(DATE)     \n```\n\n```{r}\ndf |>\n    arrange(desc(DATE))     \n```\n\n\n```{r}\ndf |>\n    arrange(MONTH, SALEPRICE)     \n```\n\n\n\n## pandas \n```{python}\ndf_pd.sort_values(by =['DATE'])   \n```\n\n```{python}\ndf_pd.sort_values(by =['DATE'], ascending = False)   \n```\n\n```{python}\ndf_pd.sort_values(by =['MONTH', 'SALEPRICE'])\n```\n\n\n:::\n\n\n### 3rd Verb - select () Function \n     Select functions help to select or obtain columns from the data frame. When there are a lot of columns in our dataset, select functions become very useful. \n\n:::{.panel-tabset}\n\n## dplyr \n```{r}\ndf |> select(DATE, UNITPRICE, DISCOUNT)   \n```\n\n\n```{r}\ndf |> select(1:2, 5:8)  \n```\n\n```{r}\ndf |>\n    select(starts_with('SIZE'))\n```\n\n```{r}\ndf |>\n    select(ends_with('PRICE'))\n```\n\n\n```{r}\ndf |>\n    select(contains(\"_\"))\n```\n\n```{r}\ndf |>\n    select(matches(\"SIZE\"))\n```\n\n```{r}\ndf |>\n    select(matches(\"PRICE$\"))\n```\n\n```{r}\n# starts with letter S\ndf |>\n    select(matches(\"^S\"))\n```\n\n\n```{r}\ndf |>\n    select(where(is.character))\n```\n\n```{r}\ndf |>\n    select(where(is.numeric))\n```\n\n```{r}\ndf |>\n    select(MONTH, YEAR, everything())\n```\n\n```{r}\n# any_of () vs all_of ()\ndf |>\n    select(any_of(c(\"PRICE\", \"SIZE\")))\n```\n\n\n```{r}\n# Dropping columns \ndf |>\n    select(-DATE)\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## pandas \n```{python}\ndf_pd['DATE']   \n```\n\n```{python}\ndf_pd[['DATE', 'UNITPRICE']]   \n```\n\n```{python}\ndf_pd.loc[:,['DATE', 'UNITPRICE']]   \n```\n\n\n```{python}\ndf_pd.iloc[:,5:8]\n```\n\n```{python}\ndf_pd.iloc[:,[3,5,8]]\n```\n\n```{python}\ndf_pd.filter(['YEAR','SALEPRICE', 'DISCOUNT', 'UNITPRICE'])\n```\n\n```{python}\ndf_pd.filter(['YEAR','SALEPRICE', 'DISCOUNT', 'UNITPRICE'])\n```\n\n```{python}\n #RegularExpression(Regex)\ndf_pd.filter(regex =\"PRICE$\") #Ends with Price\n```\n\n```{python}\ndf_pd.filter(regex =\"ˆSIZE\") #Starts with SIZE\n```\n\n\n```{python}\ndf_pd.filter(regex =\"PRICE\") #Contains the word Price\n```\n\n```{python}\ndf_pd.select_dtypes('object')\n```\n\n```{python}\ndf_pd.select_dtypes('int')\n```\n\n```{python}\ndf_pd.loc[:,df_pd.columns.str.startswith('SIZE')]\n```\n\n```{python}\ndf_pd.loc[:,df_pd.columns.str.contains('PRICE')]\n```\n\n```{python}\ndf_pd.loc[:,df_pd.columns.str.endswith('PRICE')]\n```\n\n\n```{python}\n# Dropping columns \ndf_pd.drop(columns =['SIZE_EUROPE', 'SIZE_UK'], axis=1)\n```\n\n```{python}\n# Dropping columns \ndf_pd.drop(columns =['SIZE_EUROPE', 'SIZE_UK'], axis=1)\\\n    .pipe(lambda x: x.info())\n```\n\n```{python}\n# Rearranging columns \n# Sorting Alphabetically\ndf_pd.reindex(sorted(df_pd.columns), axis =1)\n```\n\n```{python}\n# Rearranging columns \n# Sorting As You Want (ASY)\n\ncol_first = ['YEAR','MONTH']\ncol_rest = df_pd.columns.difference(col_first, sort=False).to_list()\ndf_pd2 = df_pd [col_first +col_rest]\ndf_pd2.info()\n```\n\n```{python}\n\n```\n\n```{python}\n\n```\n\n```{python}\n\n```\n\n```{python}\n\n```\n\n```{python}\n\n```\n\n:::\n\n\n### 4th Verb - rename () Function \n\n:::{.panel-tabset}\n\n## dplyr \n```{r}\n\n     \n```\n\n## pandas \n```{python}\ndf_pd \n```\n\n:::\n\n### 5th Verb - mutate () Function \n\n:::{.panel-tabset}\n\n## dplyr \n```{r}\n\n     \n```\n\n## pandas \n```{python}\n\n     \n```\n\n:::\n\n### 6th Verbs - group_by () and summarize () Functions \n\n:::{.panel-tabset}\n\n## dplyr \n```{r}\n\n     \n```\n\n## pandas \n```{python}\n\n     \n```\n\n:::\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"eda.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.551","jupyter":"python3","number-depth":5,"site-url":"https://analyticsforaccountingdata.netlify.app/","repo-url":"https://github.com/msharifbd/sharifanalytics","repo-actions":["edit","issue"],"repo-branch":"main","sharing":["twitter","facebook","linkedin"],"downloads":["pdf","epub"],"bibliography":["references.bib"],"editor":"visual","theme":"flatly","mainfont":"Georgia, serif","callout-appearance":"default","cover-image":"images/titlepage_1_alt.webp","title":"Exploratory Data Analysis (EDA)"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"pdf-book"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"block-headings":true,"jupyter":"python3","number-depth":5,"site-url":"https://analyticsforaccountingdata.netlify.app/","repo-url":"https://github.com/msharifbd/sharifanalytics","repo-actions":["edit","issue"],"repo-branch":"main","sharing":["twitter","facebook","linkedin"],"downloads":["pdf","epub"],"bibliography":["references.bib"],"editor":"visual","documentclass":"scrreprt","mainfont":"Times New Roman","sansfont":"Arial","monofont":"Courier New","colorlinks":true,"title":"Exploratory Data Analysis (EDA)"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}